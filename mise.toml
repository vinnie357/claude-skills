# mise configuration for claude-skills marketplace

[tools]
"ubi:nushell/nushell" = { version = "latest", exe = "nu" }
act = "latest"  # Local GitHub Actions testing

# Note: Lima and Colima are macOS-only tools for local act testing
# Install manually on Mac: mise install lima colima

[tasks.test]
description = "Run all validation tests (Claude native + custom)"
depends = ["test:claude", "test:marketplace", "test:plugins"]

[tasks."test:all"]
description = "Run all validation tests (Claude native + custom)"
depends = ["test:claude", "test:marketplace", "test:plugins"]

[tasks."test:claude"]
description = "Run Claude's native plugin validation"
run = """
#!/usr/bin/env nu

print "üîç Running Claude native validation..."
print ""

# Check if claude CLI is available
let claude_check = (which claude | is-not-empty)
if not $claude_check {
    print "‚ö†Ô∏è  Claude CLI not found - skipping native validation"
    print "   Install Claude Code to enable: https://claude.ai/download"
    exit 0
}

# Run Claude's native validator
let result = (do { claude plugin validate . } | complete)

if $result.exit_code == 0 {
    print $result.stdout
    print ""
    print "‚úÖ Claude native validation passed!"
} else {
    print $result.stdout
    print $result.stderr
    print ""
    print "‚ùå Claude native validation failed!"
    exit 1
}
"""

[tasks."test:marketplace"]
description = "Validate marketplace.json with custom checks (source paths, etc.)"
run = """
#!/usr/bin/env nu

print "üì¶ Validating marketplace.json (custom checks)..."

let repo_root = (git rev-parse --show-toplevel | str trim)
let marketplace_path = ($repo_root | path join ".claude-plugin" "marketplace.json")

let marketplace = (open $marketplace_path)
mut errors = []

# Check required fields
if ($marketplace | get -o name) == null {
    $errors = ($errors | append "Missing required field: name")
}

if ($marketplace | get -o owner) == null {
    $errors = ($errors | append "Missing required field: owner")
}

if ($marketplace | get -o plugins) == null {
    $errors = ($errors | append "Missing required field: plugins")
}

# Validate plugin entries
for plugin in $marketplace.plugins {
    let name = ($plugin | get -o name | default "<unnamed>")

    if ($plugin | get -o source) == null {
        $errors = ($errors | append $"Plugin '($name)' missing required field: source")
    } else {
        let source_type = ($plugin.source | describe)
        if $source_type == "string" {
            # Local source must start with "./"
            if not ($plugin.source | str starts-with "./") {
                $errors = ($errors | append $"Plugin '($name)' local source must start with './': ($plugin.source)")
            }
        } else if ($source_type | str starts-with "record") {
            # External source - validate required fields
            if ($plugin.source | get -o source) == null {
                $errors = ($errors | append $"Plugin '($name)' source object missing 'source' field")
            } else if ($plugin.source.source not-in ["github", "url"]) {
                $errors = ($errors | append $"Plugin '($name)' invalid source type: ($plugin.source.source)")
            }
            if ($plugin.source | get -o repo) == null and ($plugin.source | get -o url) == null {
                $errors = ($errors | append $"Plugin '($name)' source object missing 'repo' or 'url' field")
            }
        } else {
            $errors = ($errors | append $"Plugin '($name)' source must be string or object")
        }
    }
}

if ($errors | length) > 0 {
    print ""
    for error in $errors {
        print $"‚ùå ($error)"
    }
    print ""
    print "‚ùå marketplace.json validation failed!"
    exit 1
} else {
    print "‚úÖ marketplace.json is valid!"
}
"""

[tasks."test:plugins"]
description = "Validate all plugin.json files (local and external)"
run = """
#!/usr/bin/env nu

print "üîç Validating all plugins..."
print ""

let repo_root = (git rev-parse --show-toplevel | str trim)
let marketplace = (open ($repo_root | path join ".claude-plugin" "marketplace.json"))

mut all_passed = true
mut local_count = 0
mut external_count = 0

for plugin in $marketplace.plugins {
    let source_type = ($plugin.source | describe)

    # Handle external plugins (source is an object)
    if ($source_type | str starts-with "record") {
        $external_count = $external_count + 1

        # Only clone GitHub sources
        if ($plugin.source | get -o source) == "github" {
            let repo = ($plugin.source | get -o repo)
            let github_url = $"https://github.com/($repo).git"
            let temp_dir = (mktemp -d)

            print $"üì• plugin: ($plugin.name) [cloning from ($repo)]..."

            let clone_result = (do { git clone --depth 1 --quiet $github_url $temp_dir } | complete)
            if $clone_result.exit_code != 0 {
                print $"‚ùå plugin: ($plugin.name) - failed to clone"
                $all_passed = false
                rm -rf $temp_dir
            } else {
                # Validate the cloned plugin
                let plugin_json = ($temp_dir | path join ".claude-plugin" "plugin.json")
                if ($plugin_json | path exists) {
                    let ext_plugin = (open $plugin_json)
                    if ($ext_plugin | get -o name) == $plugin.name {
                        print $"‚úÖ plugin: ($plugin.name) [external]"
                    } else {
                        print $"‚ùå plugin: ($plugin.name) - name mismatch in plugin.json"
                        $all_passed = false
                    }
                } else {
                    print $"‚ùå plugin: ($plugin.name) - no .claude-plugin/plugin.json found"
                    $all_passed = false
                }
                rm -rf $temp_dir
            }
        } else {
            print $"‚è≠Ô∏è  plugin: ($plugin.name) [non-github external - skipped]"
        }
    } else {
        $local_count = $local_count + 1
        let result = (do { nu ($repo_root | path join "test" "validate-plugin.nu") $plugin.name } | complete)
        if $result.exit_code == 0 {
            print $"‚úÖ plugin: ($plugin.name)"
        } else {
            print $"‚ùå plugin: ($plugin.name)"
            $all_passed = false
        }
    }
}

print ""
print $"üìä Local: ($local_count), External: ($external_count)"
print ""

if $all_passed {
    print "‚ú® All plugins are valid!"
} else {
    print "‚ùå Some plugin validations failed"
    exit 1
}
"""

[tasks."test:plugin"]
description = "Validate a specific plugin (usage: mise test:plugin <plugin-name>)"
run = """
#!/usr/bin/env bash
set -e

if [ -z "$1" ]; then
    echo "‚ùå Error: Plugin name required"
    echo "Usage: mise test:plugin <plugin-name>"
    exit 1
fi

cd "$(git rev-parse --show-toplevel)"
nu test/validate-plugin.nu "$1"
"""

[tasks."update-all-skills"]
description = "Update all-skills plugin.json with all skills from all plugins"
run = """
#!/usr/bin/env bash
set -e

cd "$(git rev-parse --show-toplevel)"

# Check for flags
DRY_RUN=""
VERBOSE=""

for arg in "$@"; do
    case $arg in
        --dry-run|-d)
            DRY_RUN="--dry-run"
            ;;
        --verbose|-v)
            VERBOSE="--verbose"
            ;;
    esac
done

nu .claude-plugin/scripts/update-all-skills.nu $DRY_RUN $VERBOSE
"""

[tasks.list-plugins]
description = "List all plugins in the marketplace"
run = """
#!/usr/bin/env bash
cd "$(git rev-parse --show-toplevel)"
nu -c 'open .claude-plugin/marketplace.json | get plugins | select name version description category'
"""

[tasks."colima:start"]
description = "Start colima with Docker runtime (macOS only)"
run = """
#!/usr/bin/env nu

# Only run on macOS
if $nu.os-info.name != "macos" {
    print "‚ö†Ô∏è  Colima is only available on macOS. Ubuntu/Linux has native Docker."
    exit 0
}

# Use mise exec to run colima with temporary tool activation (like nix-shell)
print "üì¶ Checking colima status..."
let status = (mise exec lima@latest colima@latest -- colima status --profile default | complete)
if $status.exit_code != 0 {
    print "üöÄ Starting colima..."
    mise exec lima@latest colima@latest -- colima start --vm-type vz --vz-rosetta --runtime docker
} else {
    print "‚úÖ Colima is already running"
}
"""

[tasks."colima:stop"]
description = "Stop colima"
run = """
#!/usr/bin/env nu

# Only run on macOS
if $nu.os-info.name != "macos" {
    print "‚ö†Ô∏è  Colima is only available on macOS."
    exit 0
}

# Use mise exec with both lima and colima
mise exec lima@latest colima@latest -- colima stop
"""

[tasks."test:action"]
description = "Test GitHub action locally using act (tests pull_request workflow)"
run = """
#!/usr/bin/env nu

# Detect OS and set flags for Mac (using medium image - micro lacks curl/bash tools)
let act_flags = if $nu.os-info.name == "macos" {
    [
        "--container-architecture" "linux/amd64"
        "--container-daemon-socket" "-"
        "-P" "ubuntu-latest=catthehacker/ubuntu:act-latest"
    ]
} else {
    [
        "-P" "ubuntu-latest=catthehacker/ubuntu:act-latest"
    ]
}

act pull_request ...$act_flags
"""

[tasks."test:action:pr"]
description = "Test GitHub action for pull_request workflow"
run = """
#!/usr/bin/env nu

# Detect OS and set flags for Mac (using medium image - micro lacks curl/bash tools)
let act_flags = if $nu.os-info.name == "macos" {
    [
        "--container-architecture" "linux/amd64"
        "--container-daemon-socket" "-"
        "-P" "ubuntu-latest=catthehacker/ubuntu:act-latest"
    ]
} else {
    [
        "-P" "ubuntu-latest=catthehacker/ubuntu:act-latest"
    ]
}

act pull_request ...$act_flags
"""

[tasks."test:action:push"]
description = "Test GitHub action for push to main workflow"
run = """
#!/usr/bin/env nu

# Detect OS and set flags for Mac (using medium image - micro lacks curl/bash tools)
let act_flags = if $nu.os-info.name == "macos" {
    [
        "--container-architecture" "linux/amd64"
        "--container-daemon-socket" "-"
        "-P" "ubuntu-latest=catthehacker/ubuntu:act-latest"
    ]
} else {
    [
        "-P" "ubuntu-latest=catthehacker/ubuntu:act-latest"
    ]
}

act push ...$act_flags
"""

[tasks.gitleaks]
description = "Run gitleaks secret scanner (usage: mise gitleaks -- [--runtime docker|colima] [--report path])"
run = """
#!/usr/bin/env nu

let repo_root = (git rev-parse --show-toplevel | str trim)
let script_path = ($repo_root | path join "core" "skills" "security" "scripts" "gitleaks.nu")

# Build default arguments
mut args = [
    "--path" $repo_root
    "--runtime" "container"
]

# Auto-detect baseline file
let baseline_path = ($repo_root | path join ".gitleaks-baseline.json")
if ($baseline_path | path exists) {
    $args = ($args | append ["--baseline" $baseline_path])
}

# Run gitleaks script
nu $script_path ...$args
"""

[tasks."gitleaks:docker"]
description = "Run gitleaks with Docker runtime"
run = """
#!/usr/bin/env nu

let repo_root = (git rev-parse --show-toplevel | str trim)
let script_path = ($repo_root | path join "core" "skills" "security" "scripts" "gitleaks.nu")

mut args = [
    "--path" $repo_root
    "--runtime" "docker"
]

let baseline_path = ($repo_root | path join ".gitleaks-baseline.json")
if ($baseline_path | path exists) {
    $args = ($args | append ["--baseline" $baseline_path])
}

nu $script_path ...$args
"""

[tasks."gitleaks:colima"]
description = "Run gitleaks with Colima runtime"
run = """
#!/usr/bin/env nu

let repo_root = (git rev-parse --show-toplevel | str trim)
let script_path = ($repo_root | path join "core" "skills" "security" "scripts" "gitleaks.nu")

mut args = [
    "--path" $repo_root
    "--runtime" "colima"
]

let baseline_path = ($repo_root | path join ".gitleaks-baseline.json")
if ($baseline_path | path exists) {
    $args = ($args | append ["--baseline" $baseline_path])
}

nu $script_path ...$args
"""

[tasks."gitleaks:stop"]
description = "Stop all container runtimes (Docker, Colima, Apple Container)"
run = """
#!/usr/bin/env nu

print "üõë Stopping container runtimes..."

# Stop Apple Container (macOS 26+)
if (which container | is-not-empty) {
    let status = (do { ^container system status } | complete)
    if $status.exit_code == 0 {
        print "  Stopping Apple Container..."
        do { ^container system stop } | complete
        print "  ‚úÖ Apple Container stopped"
    }
}

# Stop Docker
if (which docker | is-not-empty) {
    let status = (do { ^docker info } | complete)
    if $status.exit_code == 0 {
        print "  Stopping Docker..."
        if $nu.os-info.name == "macos" {
            do { ^osascript -e 'quit app "Docker"' } | complete
            print "  ‚úÖ Docker stopped"
        } else {
            print "  ‚ö†Ô∏è  Stop Docker manually (systemctl stop docker)"
        }
    }
}

# Stop Colima
if (which mise | is-not-empty) {
    let status = (do { ^mise exec lima@latest colima@latest -- colima status } | complete)
    if $status.exit_code == 0 {
        print "  Stopping Colima..."
        do { ^mise exec lima@latest colima@latest -- colima stop } | complete
        print "  ‚úÖ Colima stopped"
    }
}

print "‚ú® Done"
"""

[tasks."gitleaks:stop:container"]
description = "Stop Apple Container runtime"
run = """
#!/usr/bin/env nu

if (which container | is-empty) {
    print "‚ö†Ô∏è  Apple Container CLI not found"
    exit 0
}

let status = (do { ^container system status } | complete)
if $status.exit_code != 0 {
    print "‚úÖ Apple Container is not running"
    exit 0
}

print "üõë Stopping Apple Container..."
let result = (do { ^container system stop } | complete)
if $result.exit_code == 0 {
    print "‚úÖ Apple Container stopped"
} else {
    print $"‚ùå Failed to stop Apple Container: ($result.stderr)"
    exit 1
}
"""

[tasks."gitleaks:stop:docker"]
description = "Stop Docker runtime"
run = """
#!/usr/bin/env nu

if (which docker | is-empty) {
    print "‚ö†Ô∏è  Docker CLI not found"
    exit 0
}

let status = (do { ^docker info } | complete)
if $status.exit_code != 0 {
    print "‚úÖ Docker is not running"
    exit 0
}

print "üõë Stopping Docker..."
if $nu.os-info.name == "macos" {
    let result = (do { ^osascript -e 'quit app "Docker"' } | complete)
    if $result.exit_code == 0 {
        print "‚úÖ Docker stopped"
    } else {
        print $"‚ùå Failed to stop Docker: ($result.stderr)"
        exit 1
    }
} else {
    print "‚ö†Ô∏è  On Linux, stop Docker manually: sudo systemctl stop docker"
}
"""

[tasks."test:version-bumps"]
description = "Check that modified plugins have version bumps (for CI)"
run = """
#!/usr/bin/env bash
set -e

cd "$(git rev-parse --show-toplevel)"

# Default to main if no base specified
BASE="${1:-main}"

nu test/check-version-bumps.nu --base "$BASE"
"""

[tasks."gitleaks:stop:colima"]
description = "Stop Colima runtime"
run = """
#!/usr/bin/env nu

if $nu.os-info.name != "macos" {
    print "‚ö†Ô∏è  Colima is only available on macOS"
    exit 0
}

let status = (do { ^mise exec lima@latest colima@latest -- colima status } | complete)
if $status.exit_code != 0 {
    print "‚úÖ Colima is not running"
    exit 0
}

print "üõë Stopping Colima..."
let result = (do { ^mise exec lima@latest colima@latest -- colima stop } | complete)
if $result.exit_code == 0 {
    print "‚úÖ Colima stopped"
} else {
    print $"‚ùå Failed to stop Colima: ($result.stderr)"
    exit 1
}
"""
