# mise configuration for claude-skills marketplace

[tools]
"ubi:nushell/nushell" = { version = "latest", exe = "nu" }
act = "latest"  # Local GitHub Actions testing

# Note: Lima and Colima are macOS-only tools for local act testing
# Install manually on Mac: mise install lima colima

# Multi-arch beads install
[tools."github:steveyegge/beads"]
version = "latest"

[tools."github:steveyegge/beads".platforms]
linux-x64 = { asset_pattern = "beads_*_linux_amd64.tar.gz" }
macos-arm64 = { asset_pattern = "beads_*_darwin_arm64.tar.gz" }

[tasks.test]
description = "Run all validation tests (Claude native + custom)"
depends = ["test:claude", "test:marketplace", "test:plugins"]

[tasks."test:all"]
description = "Run all validation tests (Claude native + custom)"
depends = ["test:claude", "test:marketplace", "test:plugins"]

[tasks."test:claude"]
description = "Run Claude's native plugin validation"
run = """
#!/usr/bin/env nu

print "üîç Running Claude native validation..."
print ""

# Check if claude CLI is available
let claude_check = (which claude | is-not-empty)
if not $claude_check {
    print "‚ö†Ô∏è  Claude CLI not found - skipping native validation"
    print "   Install Claude Code to enable: https://claude.ai/download"
    exit 0
}

# Run Claude's native validator
let result = (do { claude plugin validate . } | complete)

if $result.exit_code == 0 {
    print $result.stdout
    print ""
    print "‚úÖ Claude native validation passed!"
} else {
    print $result.stdout
    print $result.stderr
    print ""
    print "‚ùå Claude native validation failed!"
    exit 1
}
"""

[tasks."test:marketplace"]
description = "Validate marketplace.json with custom checks (source paths, etc.)"
run = """
#!/usr/bin/env nu

print "üì¶ Validating marketplace.json (custom checks)..."

let repo_root = (git rev-parse --show-toplevel | str trim)
let marketplace_path = ($repo_root | path join ".claude-plugin" "marketplace.json")

let marketplace = (open $marketplace_path)
mut errors = []

# Check required fields
if ($marketplace | get -o name) == null {
    $errors = ($errors | append "Missing required field: name")
}

if ($marketplace | get -o owner) == null {
    $errors = ($errors | append "Missing required field: owner")
}

if ($marketplace | get -o plugins) == null {
    $errors = ($errors | append "Missing required field: plugins")
}

# Validate plugin entries
for plugin in $marketplace.plugins {
    let name = ($plugin | get -o name | default "<unnamed>")

    if ($plugin | get -o source) == null {
        $errors = ($errors | append $"Plugin '($name)' missing required field: source")
    } else {
        let source_type = ($plugin.source | describe)
        if $source_type == "string" {
            # Local source must start with "./"
            if not ($plugin.source | str starts-with "./") {
                $errors = ($errors | append $"Plugin '($name)' local source must start with './': ($plugin.source)")
            }
        } else if ($source_type | str starts-with "record") {
            # External source - validate required fields
            if ($plugin.source | get -o source) == null {
                $errors = ($errors | append $"Plugin '($name)' source object missing 'source' field")
            } else if ($plugin.source.source not-in ["github", "url"]) {
                $errors = ($errors | append $"Plugin '($name)' invalid source type: ($plugin.source.source)")
            }
            if ($plugin.source | get -o repo) == null and ($plugin.source | get -o url) == null {
                $errors = ($errors | append $"Plugin '($name)' source object missing 'repo' or 'url' field")
            }
        } else {
            $errors = ($errors | append $"Plugin '($name)' source must be string or object")
        }
    }
}

if ($errors | length) > 0 {
    print ""
    for error in $errors {
        print $"‚ùå ($error)"
    }
    print ""
    print "‚ùå marketplace.json validation failed!"
    exit 1
} else {
    print "‚úÖ marketplace.json is valid!"
}
"""

[tasks."test:plugins"]
description = "Validate all plugin.json files (local and external)"
run = """
#!/usr/bin/env nu

print "üîç Validating all plugins..."
print ""

let repo_root = (git rev-parse --show-toplevel | str trim)
let marketplace = (open ($repo_root | path join ".claude-plugin" "marketplace.json"))

mut all_passed = true
mut local_count = 0
mut external_count = 0

for plugin in $marketplace.plugins {
    let source_type = ($plugin.source | describe)

    # Handle external plugins (source is an object)
    if ($source_type | str starts-with "record") {
        $external_count = $external_count + 1

        # Only clone GitHub sources
        if ($plugin.source | get -o source) == "github" {
            let repo = ($plugin.source | get -o repo)
            let github_url = $"https://github.com/($repo).git"
            let temp_dir = (mktemp -d)

            print $"üì• plugin: ($plugin.name) [cloning from ($repo)]..."

            let clone_result = (do { git clone --depth 1 --quiet $github_url $temp_dir } | complete)
            if $clone_result.exit_code != 0 {
                print $"‚ùå plugin: ($plugin.name) - failed to clone"
                $all_passed = false
                rm -rf $temp_dir
            } else {
                # Validate the cloned plugin
                let plugin_json = ($temp_dir | path join ".claude-plugin" "plugin.json")
                if ($plugin_json | path exists) {
                    let ext_plugin = (open $plugin_json)
                    if ($ext_plugin | get -o name) == $plugin.name {
                        print $"‚úÖ plugin: ($plugin.name) [external]"
                    } else {
                        print $"‚ùå plugin: ($plugin.name) - name mismatch in plugin.json"
                        $all_passed = false
                    }
                } else {
                    print $"‚ùå plugin: ($plugin.name) - no .claude-plugin/plugin.json found"
                    $all_passed = false
                }
                rm -rf $temp_dir
            }
        } else {
            print $"‚è≠Ô∏è  plugin: ($plugin.name) [non-github external - skipped]"
        }
    } else {
        $local_count = $local_count + 1
        let result = (do { nu ($repo_root | path join "test" "validate-plugin.nu") $plugin.name } | complete)
        if $result.exit_code == 0 {
            print $"‚úÖ plugin: ($plugin.name)"
        } else {
            print $"‚ùå plugin: ($plugin.name)"
            $all_passed = false
        }
    }
}

print ""
print $"üìä Local: ($local_count), External: ($external_count)"
print ""

if $all_passed {
    print "‚ú® All plugins are valid!"
} else {
    print "‚ùå Some plugin validations failed"
    exit 1
}
"""

[tasks."test:plugin"]
description = "Validate a specific plugin (usage: mise test:plugin <plugin-name>)"
run = """
#!/usr/bin/env bash
set -e

if [ -z "$1" ]; then
    echo "‚ùå Error: Plugin name required"
    echo "Usage: mise test:plugin <plugin-name>"
    exit 1
fi

cd "$(git rev-parse --show-toplevel)"
nu test/validate-plugin.nu "$1"
"""

[tasks."update-all-skills"]
description = "Update all-skills plugin.json with all skills from all plugins"
run = """
#!/usr/bin/env bash
set -e

cd "$(git rev-parse --show-toplevel)"

# Check for flags
DRY_RUN=""
VERBOSE=""

for arg in "$@"; do
    case $arg in
        --dry-run|-d)
            DRY_RUN="--dry-run"
            ;;
        --verbose|-v)
            VERBOSE="--verbose"
            ;;
    esac
done

nu .claude-plugin/scripts/update-all-skills.nu $DRY_RUN $VERBOSE
"""

[tasks.list-plugins]
description = "List all plugins in the marketplace"
run = """
#!/usr/bin/env bash
cd "$(git rev-parse --show-toplevel)"
nu -c 'open .claude-plugin/marketplace.json | get plugins | select name version description category'
"""

[tasks."colima:start"]
description = "Start colima with Docker runtime (macOS only)"
run = """
#!/usr/bin/env nu

# Only run on macOS
if $nu.os-info.name != "macos" {
    print "‚ö†Ô∏è  Colima is only available on macOS. Ubuntu/Linux has native Docker."
    exit 0
}

# Use mise exec to run colima with temporary tool activation (like nix-shell)
print "üì¶ Checking colima status..."
let status = (mise exec lima@latest colima@latest -- colima status --profile default | complete)
if $status.exit_code != 0 {
    print "üöÄ Starting colima..."
    mise exec lima@latest colima@latest -- colima start --vm-type vz --vz-rosetta --runtime docker
} else {
    print "‚úÖ Colima is already running"
}
"""

[tasks."colima:stop"]
description = "Stop colima"
run = """
#!/usr/bin/env nu

# Only run on macOS
if $nu.os-info.name != "macos" {
    print "‚ö†Ô∏è  Colima is only available on macOS."
    exit 0
}

# Use mise exec with both lima and colima
mise exec lima@latest colima@latest -- colima stop
"""

[tasks."test:action"]
description = "Test GitHub action locally using act (tests pull_request workflow)"
run = """
#!/usr/bin/env nu

# Detect OS and set flags for Mac (using medium image - micro lacks curl/bash tools)
let act_flags = if $nu.os-info.name == "macos" {
    [
        "--container-architecture" "linux/amd64"
        "--container-daemon-socket" "-"
        "-P" "ubuntu-latest=catthehacker/ubuntu:act-latest"
    ]
} else {
    [
        "-P" "ubuntu-latest=catthehacker/ubuntu:act-latest"
    ]
}

act pull_request ...$act_flags
"""

[tasks."test:action:pr"]
description = "Test GitHub action for pull_request workflow"
run = """
#!/usr/bin/env nu

# Detect OS and set flags for Mac (using medium image - micro lacks curl/bash tools)
let act_flags = if $nu.os-info.name == "macos" {
    [
        "--container-architecture" "linux/amd64"
        "--container-daemon-socket" "-"
        "-P" "ubuntu-latest=catthehacker/ubuntu:act-latest"
    ]
} else {
    [
        "-P" "ubuntu-latest=catthehacker/ubuntu:act-latest"
    ]
}

act pull_request ...$act_flags
"""

[tasks."test:action:push"]
description = "Test GitHub action for push to main workflow"
run = """
#!/usr/bin/env nu

# Detect OS and set flags for Mac (using medium image - micro lacks curl/bash tools)
let act_flags = if $nu.os-info.name == "macos" {
    [
        "--container-architecture" "linux/amd64"
        "--container-daemon-socket" "-"
        "-P" "ubuntu-latest=catthehacker/ubuntu:act-latest"
    ]
} else {
    [
        "-P" "ubuntu-latest=catthehacker/ubuntu:act-latest"
    ]
}

act push ...$act_flags
"""

[tasks.gitleaks]
description = "Run gitleaks secret scanner (usage: mise gitleaks -- [--runtime docker|colima] [--report path])"
run = """
#!/usr/bin/env nu

let repo_root = (git rev-parse --show-toplevel | str trim)
let script_path = ($repo_root | path join "plugins" "core" "skills" "security" "scripts" "gitleaks.nu")

# Build default arguments
mut args = [
    "--path" $repo_root
    "--runtime" "container"
]

# Auto-detect baseline file
let baseline_path = ($repo_root | path join ".gitleaks-baseline.json")
if ($baseline_path | path exists) {
    $args = ($args | append ["--baseline" $baseline_path])
}

# Run gitleaks script
nu $script_path ...$args
"""

[tasks."gitleaks:docker"]
description = "Run gitleaks with Docker runtime"
run = """
#!/usr/bin/env nu

let repo_root = (git rev-parse --show-toplevel | str trim)
let script_path = ($repo_root | path join "plugins" "core" "skills" "security" "scripts" "gitleaks.nu")

mut args = [
    "--path" $repo_root
    "--runtime" "docker"
]

let baseline_path = ($repo_root | path join ".gitleaks-baseline.json")
if ($baseline_path | path exists) {
    $args = ($args | append ["--baseline" $baseline_path])
}

nu $script_path ...$args
"""

[tasks."gitleaks:colima"]
description = "Run gitleaks with Colima runtime"
run = """
#!/usr/bin/env nu

let repo_root = (git rev-parse --show-toplevel | str trim)
let script_path = ($repo_root | path join "plugins" "core" "skills" "security" "scripts" "gitleaks.nu")

mut args = [
    "--path" $repo_root
    "--runtime" "colima"
]

let baseline_path = ($repo_root | path join ".gitleaks-baseline.json")
if ($baseline_path | path exists) {
    $args = ($args | append ["--baseline" $baseline_path])
}

nu $script_path ...$args
"""

[tasks."gitleaks:stop"]
description = "Stop all container runtimes (Docker, Colima, Apple Container)"
run = """
#!/usr/bin/env nu

print "üõë Stopping container runtimes..."

# Stop Apple Container (macOS 26+)
if (which container | is-not-empty) {
    let status = (do { ^container system status } | complete)
    if $status.exit_code == 0 {
        print "  Stopping Apple Container..."
        do { ^container system stop } | complete
        print "  ‚úÖ Apple Container stopped"
    }
}

# Stop Docker
if (which docker | is-not-empty) {
    let status = (do { ^docker info } | complete)
    if $status.exit_code == 0 {
        print "  Stopping Docker..."
        if $nu.os-info.name == "macos" {
            do { ^osascript -e 'quit app "Docker"' } | complete
            print "  ‚úÖ Docker stopped"
        } else {
            print "  ‚ö†Ô∏è  Stop Docker manually (systemctl stop docker)"
        }
    }
}

# Stop Colima
if (which mise | is-not-empty) {
    let status = (do { ^mise exec lima@latest colima@latest -- colima status } | complete)
    if $status.exit_code == 0 {
        print "  Stopping Colima..."
        do { ^mise exec lima@latest colima@latest -- colima stop } | complete
        print "  ‚úÖ Colima stopped"
    }
}

print "‚ú® Done"
"""

[tasks."gitleaks:stop:container"]
description = "Stop Apple Container runtime"
run = """
#!/usr/bin/env nu

if (which container | is-empty) {
    print "‚ö†Ô∏è  Apple Container CLI not found"
    exit 0
}

let status = (do { ^container system status } | complete)
if $status.exit_code != 0 {
    print "‚úÖ Apple Container is not running"
    exit 0
}

print "üõë Stopping Apple Container..."
let result = (do { ^container system stop } | complete)
if $result.exit_code == 0 {
    print "‚úÖ Apple Container stopped"
} else {
    print $"‚ùå Failed to stop Apple Container: ($result.stderr)"
    exit 1
}
"""

[tasks."gitleaks:stop:docker"]
description = "Stop Docker runtime"
run = """
#!/usr/bin/env nu

if (which docker | is-empty) {
    print "‚ö†Ô∏è  Docker CLI not found"
    exit 0
}

let status = (do { ^docker info } | complete)
if $status.exit_code != 0 {
    print "‚úÖ Docker is not running"
    exit 0
}

print "üõë Stopping Docker..."
if $nu.os-info.name == "macos" {
    let result = (do { ^osascript -e 'quit app "Docker"' } | complete)
    if $result.exit_code == 0 {
        print "‚úÖ Docker stopped"
    } else {
        print $"‚ùå Failed to stop Docker: ($result.stderr)"
        exit 1
    }
} else {
    print "‚ö†Ô∏è  On Linux, stop Docker manually: sudo systemctl stop docker"
}
"""

[tasks."test:version-bumps"]
description = "Check that modified plugins have version bumps (for CI)"
run = """
#!/usr/bin/env bash
set -e

cd "$(git rev-parse --show-toplevel)"

# Default to main if no base specified
BASE="${1:-main}"

nu test/check-version-bumps.nu --base "$BASE"
"""

[tasks."gitleaks:stop:colima"]
description = "Stop Colima runtime"
run = """
#!/usr/bin/env nu

if $nu.os-info.name != "macos" {
    print "‚ö†Ô∏è  Colima is only available on macOS"
    exit 0
}

let status = (do { ^mise exec lima@latest colima@latest -- colima status } | complete)
if $status.exit_code != 0 {
    print "‚úÖ Colima is not running"
    exit 0
}

print "üõë Stopping Colima..."
let result = (do { ^mise exec lima@latest colima@latest -- colima stop } | complete)
if $result.exit_code == 0 {
    print "‚úÖ Colima stopped"
} else {
    print $"‚ùå Failed to stop Colima: ($result.stderr)"
    exit 1
}
"""

# =============================================================================
# Beads (bd) - Distributed Git-Backed Issue Tracker
# =============================================================================

[tasks."beads:init"]
description = "Initialize beads in the repository (full mode - syncs to remote)"
run = "bd init"

[tasks."beads:init:stealth"]
description = "Initialize beads in stealth mode (local only, no commits)"
run = "bd init --stealth"

[tasks."beads:init:contributor"]
description = "Initialize beads in contributor mode (pull only, no push)"
run = "bd init --contributor"

[tasks."beads:ready"]
description = "List unblocked tasks ready for work"
run = '''
#!/usr/bin/env nu
let tasks = (bd ready --json | from json)
if ($tasks | is-empty) {
    print "No ready tasks"
} else {
    $tasks | select id title labels? | table
}
'''

[tasks."beads:list"]
description = "List all tasks with formatted output"
run = '''
#!/usr/bin/env nu
let tasks = (bd list --json | from json)
if ($tasks | is-empty) {
    print "No tasks found"
} else {
    $tasks | select id title status labels? assignee? | table
}
'''

[tasks."beads:show"]
description = "Show task details by ID"
run = '''
#!/usr/bin/env nu
def main [task_id: string] {
    let task = (bd show $task_id --json | from json)
    print $"(ansi green_bold)Task: ($task.id)(ansi reset)"
    print $"Title: ($task.title)"
    print $"Status: ($task.status)"
    if ($task.description? | is-not-empty) {
        print $"Description: ($task.description)"
    }
    if ($task.labels? | is-not-empty) {
        print $"Labels: ($task.labels | str join ', ')"
    }
    if ($task.assignee? | is-not-empty) {
        print $"Assignee: ($task.assignee)"
    }
    if ($task.dependencies? | is-not-empty) {
        print $"Depends on: ($task.dependencies | str join ', ')"
    }
    if ($task.blocking? | is-not-empty) {
        print $"Blocking: ($task.blocking | str join ', ')"
    }
}
'''

[tasks."beads:create"]
description = "Create a new task"
run = '''
#!/usr/bin/env nu
def main [
    title: string
    --description (-d): string  # Task description
    --labels (-l): string       # Comma-separated labels
    --assignee (-a): string     # Assignee name
    --parent (-p): string       # Parent task ID
] {
    mut args = ["create", $title]
    if ($description | is-not-empty) {
        $args = ($args | append ["--description", $description])
    }
    if ($labels | is-not-empty) {
        $args = ($args | append ["--labels", $labels])
    }
    if ($assignee | is-not-empty) {
        $args = ($args | append ["--assignee", $assignee])
    }
    if ($parent | is-not-empty) {
        $args = ($args | append ["--parent", $parent])
    }
    ^bd ...$args
}
'''

[tasks."beads:close"]
description = "Close a task by ID"
run = '''
#!/usr/bin/env nu
def main [task_id: string] {
    bd close $task_id
    print $"(ansi green)Closed task: ($task_id)(ansi reset)"
}
'''

[tasks."beads:reopen"]
description = "Reopen a closed task by ID"
run = '''
#!/usr/bin/env nu
def main [task_id: string] {
    bd reopen $task_id
    print $"(ansi yellow)Reopened task: ($task_id)(ansi reset)"
}
'''

[tasks."beads:sync"]
description = "Sync beads changes to git remote"
run = "bd sync"

[tasks."beads:pull"]
description = "Pull beads changes from git remote"
run = "bd pull"

[tasks."beads:status"]
description = "Show beads sync status"
run = "bd status"

[tasks."beads:dep:add"]
description = "Add a dependency (task depends on blocker)"
run = '''
#!/usr/bin/env nu
def main [
    task_id: string    # Task that will be blocked
    blocker_id: string # Task that blocks
] {
    bd dep add $task_id $blocker_id
    print $"(ansi cyan)Added dependency: ($task_id) depends on ($blocker_id)(ansi reset)"
}
'''

[tasks."beads:dep:remove"]
description = "Remove a dependency"
run = '''
#!/usr/bin/env nu
def main [
    task_id: string    # Task to unblock
    blocker_id: string # Blocker to remove
] {
    bd dep remove $task_id $blocker_id
    print $"(ansi yellow)Removed dependency: ($task_id) no longer depends on ($blocker_id)(ansi reset)"
}
'''

[tasks."beads:dep:graph"]
description = "Show dependency graph"
run = "bd dep graph"

[tasks."beads:comment"]
description = "Add a comment to a task"
run = '''
#!/usr/bin/env nu
def main [
    task_id: string # Task ID
    body: string    # Comment body
] {
    bd comment $task_id $body
    print $"(ansi green)Added comment to: ($task_id)(ansi reset)"
}
'''

[tasks."beads:assign"]
description = "Assign a task to someone"
run = '''
#!/usr/bin/env nu
def main [
    task_id: string  # Task ID
    assignee: string # Assignee name
] {
    bd assign $task_id $assignee
    print $"(ansi cyan)Assigned ($task_id) to ($assignee)(ansi reset)"
}
'''

[tasks."beads:label"]
description = "Add labels to a task"
run = '''
#!/usr/bin/env nu
def main [
    task_id: string # Task ID
    labels: string  # Comma-separated labels to add
] {
    bd label $task_id --add $labels
    print $"(ansi cyan)Added labels to ($task_id): ($labels)(ansi reset)"
}
'''

[tasks."beads:tree"]
description = "Show task hierarchy tree"
run = '''
#!/usr/bin/env nu
def main [task_id?: string] {
    if ($task_id | is-empty) {
        bd tree
    } else {
        bd tree $task_id
    }
}
'''

[tasks."beads:rebuild"]
description = "Rebuild SQLite cache from JSONL files"
run = "bd rebuild"
